# Jenkins-CI-D
ðŸ”¹What is Jenkins?

Jenkins is an open-source automation server that helps automate the building, testing, and deployment of software. It is widely used for continuous integration (CI) and continuous delivery (CD) pipelines.

In simpler terms, Jenkins allows developers to automate various tasks in the software development process, such as:

Building projects: Automatically compiling and building software whenever new changes are pushed to a code repository.

Running tests: Running automated tests to ensure that the code works as expected.

Deploying applications: Automatically deploying applications to different environments, like testing, staging, or production.

Jenkins is highly extensible through plugins and can be integrated with many other tools such as version control systems (e.g., Git), build tools (e.g., Maven, Gradle), and deployment platforms (e.g., Docker, Kubernetes).

ðŸ”¹Important points for Jenkins Declarative Pipelines

Introduction to Jenkins Declarative Pipelines:

Overview of Jenkins and its role in continuous integration and delivery. Explanation of declarative pipelines and their benefits. Declarative pipelines provide a more structured and simplified approach to defining pipelines in Jenkins. They offer better readability, maintainability, and reusability compared to scripted pipelines.

Structure of a Declarative Pipeline:

Stages and steps: Defining the different stages of the pipeline and the tasks performed in each stage. Stages represent logical divisions in the pipeline, such as build, test, and deploy. Steps define the individual tasks within each stage, such as code checkout, compilation, testing, and deployment. Agent: Specifying the execution environment for the pipeline, such as a specific Jenkins node or a container. Agents allow pipelines to run on designated resources, providing control over where each stage or step executes.

Syntax and Configuration:

Declarative pipeline syntax: Understanding the syntax used to define pipelines in Jenkins. Discuss the use of the pipeline block and its sections (agent, stages, steps, etc.). Explain defining and using variables, loops, conditionals, and function calls within the pipeline script. Pipeline script: Defining the pipeline stages, steps, and other configuration options using the script. Explain how to define stages using the stage block and steps using various built-in and custom steps.

Building Blocks of Declarative Pipelines:

Steps: Overview of commonly used built-in steps for actions like code checkout, building, testing, and deployment. Discuss steps like git, sh, npm, docker, JUnit, archive, deploy, etc. Environment variables: Using environment variables to store and access information throughout the pipeline. Explain how to define and use environment variables within the pipeline script. Discuss the use of environment variables for storing credentials, build numbers, and other useful data. Parameters: Defining parameters to make pipelines more flexible and customizable. Discuss different parameter types (e.g., string, boolean, choice) and their usage. Explain how to prompt users for input and use parameter values within the pipeline script. Post actions: Configuring post-build actions, such as sending notifications or publishing reports. Explain how to use the post block to define actions that execute after the pipeline completes. Discuss actions like always, success, failure, unstable, email, junit, slack, etc.

Pipeline Visualization and Logs:

Blue Ocean: Introduction to the Blue Ocean plugin for Jenkins, providing a graphical visualization of pipeline execution. Discuss the benefits of using Blue Ocean to visualize pipelines and monitor their progress. Explain how to navigate the Blue Ocean interface and interpret the pipeline visualization. Pipeline logs: Understanding how to view and analyze the logs generated by pipeline executions. Explain how to access and review console output and log files generated during pipeline execution. Discuss strategies for troubleshooting and debugging pipeline issues using the logs.

ðŸ”¹Jenkins Setup on AWS

step-01:- jenkins requires java to run. so, first install java

step-02:- install jenkins

step-03:- generate Launch Instance

step-04:- after the launch instance add port no. 8080 into the inbound rules in security.

step-05:- copy the public IPV4 address and paste it into new tab with 8080 port .

step-06:- copy the address and paste it into your localhost

step-07:- after it shows password copy it and paste into your unlock jenkins

step-08:- choose a first one option

step-09:- it getting started

step-10:- create admin user

step-11:- Save and Finish

ðŸ”¹Jenkins UI Flow

1. Login & Dashboard

Access Jenkins via a web browser (http://<JENKINS_HOST>:8080).

Login using admin credentials.

The Dashboard displays all available jobs, build history, and system status.

2. Creating a New Job (Freestyle or Pipeline)

Click on "New Item".

Choose a job type:

Freestyle Project â€“ Simple configuration with build steps.

Pipeline â€“ Uses Groovy scripts to define CI/CD workflows.

Multibranch Pipeline â€“ Automatically discovers branches in SCM.

Provide a job name and click OK.

3. Configuring the Job

Configure Source Code Management (SCM) (Git, SVN, etc.).

Define Build Triggers (manual, scheduled, webhook, SCM poll).

Add Build Steps (Shell scripts, Maven, Gradle, Docker, etc.).

Configure Post-build Actions (publish reports, trigger next job).

4. Running the Job

Click "Build Now" to manually trigger a build.

View the Build Queue and Console Output for real-time logs.

5. Managing Pipelines with Jenkinsfile

Pipelines can be defined using a Jenkinsfile stored in the repository.

Supports Declarative and Scripted syntax.

ðŸ”¹GROOVY :-

In Jenkins, Groovy is a powerful scripting language that's heavily used for automating tasks and customizing Jenkins pipelines. Jenkins uses Groovy in two main pipeline syntax:

(1) Declarative pipe

(2) Static type

Groovy E.X:-

IN Linux for clone you can write git clone _______(URL name)

in the Groovy you can wrrite git URL:_________ branch:__________

ðŸ§° Why is Groovy used in Jenkins?

Jenkins uses Groovy to:

Define Pipelines
Automate your CI/CD (build, test, deploy) steps.

Write Logic
Add conditions, loops, and functions to customize your builds.

Admin Tasks
Manage Jenkins settings and jobs from the Script Console using Groovy.

1. Declarative Pipeline (also called "Static")

Easier to read and write

Structure is fixed with predefined keywords (pipeline, agent, stages, steps, etc.)

Best for beginners or standard workflows

ðŸ§¾ Example:

Static pipe:-

ðŸ”¹Letâ€™s now build the actual pipeline in detail.

Step 01:- code clone using groovy

git URL:_________ branch:__________

If you add a simple file to GitHub and build in Jenkins now, it wonâ€™t clone the whole repository again â€” it will just pull the new file.

now click on build Now in jenkins

Step 02:- docker build

if you want to run shell command use sh â€œ_______â€œ.

It failed. So, follow the steps below:
First, check the Docker console output to see why it failed.
Then, correct the code accordingly.

solve above problem first install docker

In the Jenkins pipeline, the user is 'jenkins' (not the default 'ubuntu' user). So, we need to add the 'jenkins' user to the 'docker' group and refresh the group membership. Additionally, we should also add the 'ubuntu' user to the 'docker' group if needed

So, we need to add both the 'jenkins' and 'ubuntu' users to the 'docker' group.

Step 03:- Deploy using docker compose

Now open flask app through port 5000

Check the port configuration in the Docker Compose file in the GitHub repository.

Edit inbound rules in aws

Now, check if we update the code in GitHub, the changes will be applied here automatically

It failed here. Now, use the logs to understand why it failed.

it shows like this error because we have not permission of mysql-data

so we can change owner of mysql with jenkins

Please change the ownership of a directory and its contents using the command below.

chown -R your_username:your_group folder

Here, the root is not changed because it is the group, but it is working now.

now mysql data has jenkins permission

now it is work

but the changes is not shown in the flask app heading .

so , build a robust build compose you have to add (â€”build flask-app)

Now the changes are visible in the Flask + MySQL app by Bhagya Patel.

ðŸ”¹Automate CI/CD

Open Docker Hub and log in. Then, add some shell commands to push the image.

But it's still not working, so use credentials.
Write the username and password in the global credentials in Jenkins.
Then, go to the credentials section and add the credentials.

For the username and password, go to Docker Hub.
To get the password, generate a new access token.

Now, generate the access token. After that, when the password prompt appears, copy the token and paste it into the global credentials password field.

The withCredentials function allows you to use credentials such as username, password, SSH key, etc.

The usernamePassword function allows you to retrieve the username or password using their IDs, but they are displayed in a square box or list.

To store data, we use variables. For example, we use passwordVariable to store the password and usernameVariable to store the username.

By using env, you can access these variables.

Now, build your pipeline and follow the steps below.
It will successfully appear in your Docker Hub repositories, and the process can be set up for continuous delivery.

If you want continuous deployment, it means the process is done automatically without clicking a button. Once the coder writes code in GitHub, it is automatically deployed through Jenkins.

GitHub integrated with Jenkins is known as a webhook.

To set up webhooks, first go to GitHub, then navigate to the settings, select 'Webhooks,' and add the webhook.

for a expose it change a ip address in aws with any where for a port no. 8080

now copy the jenkins URL and paste it web hooks

but in URL add after port add github-webhook/

Now, go to the Jenkins pipeline and choose the GitHub hook under the triggers section.

now without trigger (Build now) it is automatically trigger after the commit it automatically change

it is automatically change. now you can say that my pipeline is robust.

But if you want to make changes to the pipeline, you need to go to Jenkins. It's better to connect it with version control.

So, add a new file in GitHub, name it Jenkinsfile, paste all the pipeline code inside, and commit the changes.

Afterward, go to Jenkins and change the definition to 'Pipeline script from SCM

copy the above URL

Now, everything is automated.
First, take the pipeline from GitHub, and then proceed with the rest of the steps.
